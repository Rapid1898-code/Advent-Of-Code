# Testdaten Advent 9
#liste_src = [109,1,204,-1,1001,100,1,100,1008,100,16,101,1006,101,0,99]
#liste_src = [1102,34915192,34915192,7,4,7,99,0]
#liste_src = [104,1125899906842624,99]
#liste_src = [1102,34463338,34463338,63,1007,63,34463338,63,1005,63,53,1102,3,1,1000,109,988,209,12,9,1000,209,6,209,3,203,0,1008,1000,1,63,1005,63,65,1008,1000,2,63,1005,63,904,1008,1000,0,63,1005,63,58,4,25,104,0,99,4,0,104,0,99,4,17,104,0,99,0,0,1101,0,31,1019,1101,25,0,1008,1102,35,1,1009,1102,422,1,1029,1102,1,21,1005,1102,1,734,1027,1102,29,1,1000,1101,32,0,1018,1102,28,1,1016,1101,0,38,1015,1101,0,378,1023,1101,30,0,1017,1102,1,381,1022,1101,0,37,1006,1102,1,1,1021,1101,0,24,1011,1102,1,23,1002,1101,0,0,1020,1101,0,20,1007,1101,427,0,1028,1101,26,0,1014,1101,27,0,1010,1101,0,39,1001,1101,34,0,1012,1102,1,36,1013,1101,0,33,1003,1101,804,0,1025,1101,737,0,1026,1102,1,809,1024,1102,1,22,1004,109,9,1201,-7,0,63,1008,63,20,63,1005,63,205,1001,64,1,64,1106,0,207,4,187,1002,64,2,64,109,2,21102,40,1,1,1008,1012,40,63,1005,63,233,4,213,1001,64,1,64,1106,0,233,1002,64,2,64,109,4,1208,-7,25,63,1005,63,255,4,239,1001,64,1,64,1106,0,255,1002,64,2,64,109,-24,1207,10,38,63,1005,63,271,1105,1,277,4,261,1001,64,1,64,1002,64,2,64,109,25,21107,41,40,-3,1005,1013,293,1105,1,299,4,283,1001,64,1,64,1002,64,2,64,109,5,1205,-1,311,1106,0,317,4,305,1001,64,1,64,1002,64,2,64,109,-23,1202,6,1,63,1008,63,22,63,1005,63,339,4,323,1105,1,343,1001,64,1,64,1002,64,2,64,109,1,2101,0,2,63,1008,63,37,63,1005,63,367,1001,64,1,64,1106,0,369,4,349,1002,64,2,64,109,29,2105,1,-5,1106,0,387,4,375,1001,64,1,64,1002,64,2,64,109,-26,2101,0,0,63,1008,63,23,63,1005,63,409,4,393,1106,0,413,1001,64,1,64,1002,64,2,64,109,26,2106,0,0,4,419,1106,0,431,1001,64,1,64,1002,64,2,64,109,-17,21108,42,42,6,1005,1017,453,4,437,1001,64,1,64,1106,0,453,1002,64,2,64,109,7,21101,43,0,-8,1008,1010,44,63,1005,63,477,1001,64,1,64,1105,1,479,4,459,1002,64,2,64,109,-7,1206,10,495,1001,64,1,64,1106,0,497,4,485,1002,64,2,64,109,-5,2108,36,0,63,1005,63,513,1106,0,519,4,503,1001,64,1,64,1002,64,2,64,109,3,2102,1,-5,63,1008,63,22,63,1005,63,541,4,525,1105,1,545,1001,64,1,64,1002,64,2,64,109,3,1207,-6,38,63,1005,63,567,4,551,1001,64,1,64,1105,1,567,1002,64,2,64,109,-15,2107,20,8,63,1005,63,585,4,573,1106,0,589,1001,64,1,64,1002,64,2,64,109,-1,1208,5,36,63,1005,63,609,1001,64,1,64,1106,0,611,4,595,1002,64,2,64,109,30,21101,44,0,-7,1008,1019,44,63,1005,63,633,4,617,1106,0,637,1001,64,1,64,1002,64,2,64,109,-25,1201,0,0,63,1008,63,39,63,1005,63,659,4,643,1105,1,663,1001,64,1,64,1002,64,2,64,109,27,1206,-8,677,4,669,1106,0,681,1001,64,1,64,1002,64,2,64,109,-28,2108,29,0,63,1005,63,703,4,687,1001,64,1,64,1106,0,703,1002,64,2,64,109,5,21107,45,46,7,1005,1012,725,4,709,1001,64,1,64,1106,0,725,1002,64,2,64,109,30,2106,0,-8,1105,1,743,4,731,1001,64,1,64,1002,64,2,64,109,-22,21102,46,1,4,1008,1017,44,63,1005,63,767,1001,64,1,64,1105,1,769,4,749,1002,64,2,64,109,-15,1202,10,1,63,1008,63,23,63,1005,63,793,1001,64,1,64,1106,0,795,4,775,1002,64,2,64,109,19,2105,1,7,4,801,1105,1,813,1001,64,1,64,1002,64,2,64,109,6,1205,-2,827,4,819,1106,0,831,1001,64,1,64,1002,64,2,64,109,-20,2107,22,2,63,1005,63,851,1001,64,1,64,1106,0,853,4,837,1002,64,2,64,109,20,21108,47,44,-8,1005,1015,869,1105,1,875,4,859,1001,64,1,64,1002,64,2,64,109,-22,2102,1,4,63,1008,63,23,63,1005,63,899,1001,64,1,64,1106,0,901,4,881,4,64,99,21101,0,27,1,21102,915,1,0,1106,0,922,21201,1,28703,1,204,1,99,109,3,1207,-2,3,63,1005,63,964,21201,-2,-1,1,21101,0,942,0,1106,0,922,22101,0,1,-1,21201,-2,-3,1,21101,957,0,0,1105,1,922,22201,1,-1,-2,1105,1,968,21201,-2,0,-2,109,-3,2105,1,0]

# Testdaten Advent7 - Loop-Modus
#liste_src = [3,26,1001,26,-4,26,3,27,1002,27,2,27,1,27,26,27,4,27,1001,28,-1,28,1005,28,6,99,0,0,5]
#liste_src = [3,52,1001,52,-5,52,3,53,1,52,56,54,1007,54,5,55,1005,55,26,1001,54,-5,54,1105,1,12,1,53,54,53,1008,54,0,55,1001,55,1,55,2,53,55,53,4,53,1001,56,-1,56,1005,56,6,99,0,0,0,0,10]
#liste_src =[3,8,1001,8,10,8,105,1,0,0,21,34,51,64,81,102,183,264,345,426,99999,3,9,102,2,9,9,1001,9,4,9,4,9,99,3,9,101,4,9,9,102,5,9,9,1001,9,2,9,4,9,99,3,9,101,3,9,9,1002,9,5,9,4,9,99,3,9,102,3,9,9,101,3,9,9,1002,9,4,9,4,9,99,3,9,1002,9,3,9,1001,9,5,9,1002,9,5,9,101,3,9,9,4,9,99,3,9,102,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,101,1,9,9,4,9,3,9,101,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,99,3,9,101,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,2,9,4,9,3,9,101,1,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,1,9,9,4,9,99,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,101,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,2,9,4,9,3,9,1002,9,2,9,4,9,99,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,1,9,4,9,99,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,101,1,9,9,4,9,99]

# Input _ Advent11 - Robot
liste_src = [3,8,1005,8,334,1106,0,11,0,0,0,104,1,104,0,3,8,102,-1,8,10,101,1,10,10,4,10,108,0,8,10,4,10,1002,8,1,28,2,1108,5,10,3,8,102,-1,8,10,101,1,10,10,4,10,1008,8,1,10,4,10,1001,8,0,55,1,102,18,10,1,2,5,10,3,8,1002,8,-1,10,1001,10,1,10,4,10,108,1,8,10,4,10,1001,8,0,84,1,106,11,10,2,1008,6,10,1,4,4,10,1006,0,55,3,8,1002,8,-1,10,1001,10,1,10,4,10,108,0,8,10,4,10,102,1,8,121,1,107,9,10,3,8,102,-1,8,10,101,1,10,10,4,10,108,1,8,10,4,10,101,0,8,147,2,1002,4,10,2,104,18,10,1,107,16,10,1,108,8,10,3,8,102,-1,8,10,101,1,10,10,4,10,108,0,8,10,4,10,102,1,8,185,3,8,1002,8,-1,10,1001,10,1,10,4,10,1008,8,0,10,4,10,101,0,8,208,2,1009,16,10,1006,0,7,1006,0,18,1,1105,8,10,3,8,1002,8,-1,10,101,1,10,10,4,10,108,1,8,10,4,10,101,0,8,243,2,1105,20,10,2,106,10,10,1006,0,67,3,8,1002,8,-1,10,101,1,10,10,4,10,108,0,8,10,4,10,1001,8,0,276,2,1103,5,10,2,1104,7,10,1006,0,35,2,1105,3,10,3,8,1002,8,-1,10,101,1,10,10,4,10,1008,8,1,10,4,10,1002,8,1,314,101,1,9,9,1007,9,1097,10,1005,10,15,99,109,656,104,0,104,1,21102,936995824532,1,1,21101,0,351,0,1105,1,455,21102,1,387508445964,1,21102,362,1,0,1106,0,455,3,10,104,0,104,1,3,10,104,0,104,0,3,10,104,0,104,1,3,10,104,0,104,1,3,10,104,0,104,0,3,10,104,0,104,1,21102,1,235244973059,1,21101,409,0,0,1106,0,455,21102,179410541659,1,1,21101,0,420,0,1105,1,455,3,10,104,0,104,0,3,10,104,0,104,0,21101,868402070292,0,1,21102,1,443,0,1106,0,455,21102,1,709584749324,1,21102,454,1,0,1106,0,455,99,109,2,22102,1,-1,1,21101,40,0,2,21102,486,1,3,21101,0,476,0,1106,0,519,109,-2,2105,1,0,0,1,0,0,1,109,2,3,10,204,-1,1001,481,482,497,4,0,1001,481,1,481,108,4,481,10,1006,10,513,1101,0,0,481,109,-2,2106,0,0,0,109,4,2102,1,-1,518,1207,-3,0,10,1006,10,536,21102,0,1,-3,21202,-3,1,1,22102,1,-2,2,21102,1,1,3,21102,555,1,0,1106,0,560,109,-4,2106,0,0,109,5,1207,-3,1,10,1006,10,583,2207,-4,-2,10,1006,10,583,21201,-4,0,-4,1106,0,651,21201,-4,0,1,21201,-3,-1,2,21202,-2,2,3,21102,602,1,0,1106,0,560,22102,1,1,-4,21101,0,1,-1,2207,-4,-2,10,1006,10,621,21102,0,1,-1,22202,-2,-1,-2,2107,0,-3,10,1006,10,643,21201,-1,0,1,21102,643,1,0,106,0,518,21202,-2,-1,-2,22201,-4,-2,-4,109,-5,2106,0,0]

import itertools

# erstellt Liste mit allen Kombinationsmöglichkeiten des Parameters und stellt sie in eine Liste
def make_combi(numb):
    combi2 = []
    combi = itertools.permutations(numb, len(numb))
    for i in combi:
        combi2.append(i)
    return combi2

# Initialisiert die Liste mit x bis zum Maximalwert
def memory_extend(list_extend_index):
    for j in range(list_extend_index - len(liste) + 2):
        liste.append(0)

# Prüft ob ein Werte über die Grenze der Liste hinausgeht
def memory_check (instruct, werte):
    global i
    max = 0
    for j in range (0,len(werte)):
        if (instruct[j] == '0' or instruct[j] == '2') and werte[j] > max: max = werte[j]
    if max > len(liste): memory_extend(int(max))

def robo_move (kennzei):
    global robo_color, robo_dir, ergebnis, x, y
    # print (x,y, kennzei, robo_color, robo_dir, ergebnis)
    # if int(str(liste[i])[-1]) in (1, 2, 7, 8): print(i, liste[i:i + 4])
    # elif int(str(liste[i])[-1]) in (5, 6): print(i, liste[i:i + 3])
    # elif int(str(liste[i])[-1]) in (3, 4, 9): print(i, liste[i:i + 2])
    if kennzei == 0:
        if robo_color == ' ':
            robo_color = 'Farbe'
            grid[x][y] == 0
            if [x,y] not in fields:
                ergebnis += 1
                fields.append([x,y])
        elif robo_color == 'Farbe':
            robo_color = ' '
            if robo_dir == 'O': robo_dir = 'L'
            elif robo_dir == 'L': robo_dir = 'U'
            elif robo_dir == 'U': robo_dir = 'R'
            elif robo_dir == 'R': robo_dir = 'O'
    elif kennzei == 1:
        if robo_color == ' ':
            robo_color = 'Farbe'
            grid[x][y] == 1
            if [x,y] not in fields:
                ergebnis += 1
                fields.append([x,y])
        elif robo_color == 'Farbe':
            robo_color = ' '
            if robo_dir == 'O': robo_dir = 'R'
            elif robo_dir == 'L': robo_dir = 'O'
            elif robo_dir == 'U': robo_dir = 'L'
            elif robo_dir == 'R': robo_dir = 'U'
    if robo_dir == 'O': y -= 1
    if robo_dir == 'L': x -= 1
    if robo_dir == 'R': x += 1
    if robo_dir == 'U': y += 1

                # 2 Zahlen addieren lt. Position
# OPCODE 1
def op_add(erg, wert1, wert2):
    global i
    try:
        liste[erg] = wert1 + wert2
    except:
        memory_extend(liste[erg])
        liste[erg] = wert1 + wert2
    i += 4

# 2 Zahlen multiplizieren lt. Position
# OPCODE 2
def op_mult(erg, wert1, wert2):
    global i
    try:
        liste[erg] = wert1 * wert2
    except:
        memory_extend(liste[erg])
        liste[erg] = wert1 * wert2
    i += 4

# Eingabe eines Wertes lt. Position
# bei 0 erfolgt Eingabe lt. Position
# bei 1 erfolgt Eingabe direkt für die akt. Position
# bei I1 wird der Code lt. Position geschrieben
# bei I2 wird der Code lt. Position geschrieben
# OPCODE 3
def op_in(inst, code):
    global i
    global relative_base
    global mode, x, y
    if inst == '0':     # Abfrage für manuelle Eingabe im Positionsmode (alte Logik)
        inp = input("Input: ")
        liste[liste[i + 1]] = int(inp)
    elif inst == '1':   # Abfrage für manuelle Eingabe im Direktmode (alte Logik
        inp = input("Input: ")
        liste[i + 1] = int(inp)
    elif inst == '2':
        inp = input("Input: ")
        liste[liste[i + 1]+relative_base] = int(inp)
    elif inst == "I": liste[liste[i + 1]] = code
    else: print('Error F! ', inst)
    i += 2

# Ausgabe bei return eines Wertes aus der Funktion
# bei 0 erfolgt Ausgabe lt. Position
# bei 1 erfolgt Ausgabe direkt für die akt. Position
# OPCODE 4
def op_out(inst):
    global i, mode, relative_base, robo_color, robo_dir
    if mode == 'LOOP':
        if inst == '0':
            return (liste[liste[i + 1]])
        elif inst == '1':
            return (liste[i + 1])
        elif inst == '2':
            return (liste[liste[i + 1]+relative_base])
    elif mode == 'TEST':
        if inst == '0': print("Output: ", liste[liste[i + 1]])      # was necessary for Advent5
        elif inst == '1': print("Output: ", liste[i + 1])
        elif inst == '2': print("Output: ", liste[liste[i + 1]+relative_base])
    elif mode == 'ROBOT':
        if inst == '0': robo_move(liste[liste[i + 1]])
        elif inst == '1': robo_move(liste[i + 1])
        elif inst == '2': robo_move(liste[liste[i + 1]+relative_base])
    else: print ('Error D! ', inst)
    i += 2

# Vergleich ob der Wert <> 0 ist
# Parameter1 gibt an ob der Pointer lt. Position (0) oder direkter Wert (1) gesetzt werden soll
# Parameter2 gib an ob die Prüfung <> 0 lt. Position (0) oder direktem Wert (1) erfolgen soll
# OPCODE 5
def op_true(in1, in2):      # in2 ist der erste Parameter nach dem Operanden - in1 ist der zweite parameter nach dem Operanden
    global i
    global relative_base
    if in2 == '0':
        if liste[liste[i+1]] != 0:
            if in1 == '0':
                i = liste[liste[i + 2]]
            elif in1 == '1':
                i = liste[i + 2]
            elif in1 == '2':
                i = liste[liste[i + 2]+relative_base]
        else:
            i += 3
    elif in2 == '1':
        if liste[i + 1] != 0:
            if in1 == '0':
                i = liste[liste[i + 2]]
            elif in1 == '1':
                i = liste[i + 2]
            elif in1 == '2':
                i = liste[liste[i + 2]+ relative_base]
        else:
            i += 3
    elif in2 == '2':
        if liste[liste[i+1]+relative_base] != 0:
            if in1 == '0':
                i = liste[liste[i + 2]]
            elif in1 == '1':
                i = liste[i + 2]
            elif in1 == '2':
                i = liste[liste[i + 2]+relative_base]
        else:
            i += 3

# Vergleich ob der Wert = 0 ist
# Parameter1 gibt an ob der Pointer lt. Position (0) oder direkter Wert (1) gesetzt werden soll
# Parameter2 gib an ob die Prüfung = 0 lt. Position (0) oder direktem Wert (1) erfolgen soll
# OPCODE 6
def op_false(in1, in2):
    global i
    global relative_base
    if in2 == '0':
        if liste[liste[i+1]] == 0:
            if in1 == '0':
                i = liste[liste[i + 2]]
            elif in1 == '1':
                i = liste[i + 2]
            elif in1 == '2':
                i = liste[liste[i + 2]+relative_base]
        else:
            i += 3
    elif in2 == '1':
        if liste[i + 1] == 0:
            if in1 == '0':
                i = liste[liste[i + 2]]
            elif in1 == '1':
                i = liste[i + 2]
            elif in1 == '2':
                i = liste[liste[i + 2] + relative_base]
        else:
            i += 3
    elif in2 == '2':
        if liste[liste[i+1]+relative_base] == 0:
            if in1 == '0':
                i = liste[liste[i + 2]]
            elif in1 == '1':
                i = liste[i + 2]
            elif in1 == '2':
                i = liste[liste[i + 2]+relative_base]
        else:
            i += 3

# 2 Werte werden verglichen - wenn < wird 1 ausgegeben - sonst 0
# # Parameter1 gibt an ob der Pointer lt. Position (0) oder direkter Wert (1) gesetzt werden soll
# # Parameter2 gib an ob die Prüfung lt. Position (0) oder direktem Wert (1) erfolgen soll
# OPCODE 7:
def op_less(in0, in1, in2):
    global i
    global relative_base
    if in2 == '0':
        v1 = liste[liste[i + 1]]
    elif in2 == '1':
        v1 = liste[i + 1]
    elif in2 == '2':
        v1 = liste[liste[i + 1]+relative_base]

    if in1 == '0':
        v2 = liste[liste[i + 2]]
    elif in1 == '1':
        v2 = liste[i + 2]
    elif in1 == '2':
        v2 = liste[liste[i + 2]+relative_base]

    if v1 < v2:
        if in0 == '0': liste[liste[i + 3]] = 1
        elif in0 == '1': liste[i + 3] = 1
        elif in0 == '2':
            try:
                liste[liste[i + 3] + relative_base] = 1
            except:
                memory_extend(liste[liste[i + 3] + relative_base])
                liste[liste[i + 3] + relative_base] = 1
    elif v1 >= v2:
        if in0 == '0': liste[liste[i + 3]] = 0
        elif in0 == '1': liste[i + 3] = 0
        elif in0 == '2':
            try:
                liste[liste[i + 3] + relative_base] = 0
            except:
                memory_extend(liste[liste[i + 3] + relative_base])
                liste[liste[i + 3] + relative_base] = 0
    i += 4

# 2 Werte werden verglichen - wenn = wird 1 ausgegeben - sonst 0
# # Parameter1 gibt an ob der Pointer lt. Position (0) oder direkter Wert (1) gesetzt werden soll
# # Parameter2 gib an ob die Prüfung lt. Position (0) oder direktem Wert (1) erfolgen soll
# OPCODE 8
def op_equal(in0, in1, in2):    # in2 ist der 1. Parameter nach dem Code, dann in1 und dann in0 wor der Werte gespeichert werden soll
    global i
    global relative_base
    if in2 == '0':
        v1 = liste[liste[i + 1]]
    elif in2 == '1':
        v1 = liste[i + 1]
    elif in2 == '2':
        v1 = liste[liste[i + 1] + relative_base]

    if in1 == '0':
        v2 = liste[liste[i + 2]]
    elif in1 == '1':
        v2 = liste[i + 2]
    elif in1 == '2':
        v2 = liste[liste[i + 2] + relative_base]

    if v1 == v2:
        if in0 == '0': liste[liste[i + 3]] = 1
        elif in0 == '1': liste[i + 3] = 1
        elif in0 == '2':
            try:
                liste[liste[i + 3] + relative_base] = 1
            except:
                memory_extend(liste[liste[i + 3] + relative_base])
                liste[liste[i + 3] + relative_base] = 1
    elif v1 != v2:
        if in0 == '0': liste[liste[i + 3]] = 0
        elif in0 == '1': liste[i + 3] = 0
        elif in0 == '2':
            try:
                liste[liste[i + 3] + relative_base] = 0
            except:
                memory_extend(liste[liste[i + 3] + relative_base])
                liste[liste[i + 3] + relative_base] = 0
    i += 4

# OPCODE 9
def op_relative(in1):
    global i
    global relative_base
    if in1 == '0':
        relative_base += liste[liste[i+1]]
    elif in1 == '1':
        relative_base += liste[i+1]
    elif in1 == '2':
        relative_base += liste[liste[i+1]+relative_base]
    else: print("Error op_relative", in1)
    i += 2

def val_instruct(in1, in2):         # v1 erste Zahl nach operand xx z.B. 01, v2 zweite Zahlen nach 01
    global i
    global relative_base
    if in2 == '0':
        v1 = liste[liste[i + 1]]
    elif in2 == '1':
        v1 = liste[i + 1]
    elif in2 == '2':
        v1 = liste[liste[i + 1]+relative_base]
    else:
        print("ErrorA! ", in2)
    if in1 == '0':
        v2 = liste[liste[i + 2]]
    elif in1 == '1':
        v2 = liste[i + 2]
    elif in1 == '2':
        v2 = liste[liste[i + 2]+relative_base]
    else:
        print("ErrorB! ", in1)
    return v1, v2


# Eigentlichs Herzstück des Int-Computers
# bei optout wird ergebnis der Funktion zurückgegeben
def int_comp(code1,code2):
    global i, inp_inst, loop, mode, relative_base, robo_color, robo_dir
    while True:
        # if int(str(liste[i])[-1]) in (1,2,7,8): print(i, liste[i:i+4])
        # elif int(str(liste[i])[-1]) in (5,6): print(i, liste[i:i+3])
        # elif int(str(liste[i])[-1]) in (3,4,9): print(i, liste[i:i+2])
        if liste[i] == 99:
            if mode == 'LOOP':
                loop = False
                return (code2)
            elif mode == 'TEST':
                break
            elif mode == 'ROBOT':
                break
        if liste[i] == 1:
            op_add(liste[i + 3], liste[liste[i + 1]], liste[liste[i + 2]])
            continue
        if liste[i] == 2:
            if liste[i+1] > len(liste): memory_extend(liste[i+1]+5)
            if liste[i+2] > len(liste): memory_extend(liste[i+2]+5)
            if liste[i+3] > len(liste): memory_extend(liste[i+3]+5)
            op_mult(liste[i + 3], liste[liste[i + 1]], liste[liste[i + 2]])
            continue
        if liste[i] == 3:
            if mode == "ROBOT":
                if grid[x][y] == 'B': op_in('I',0)
                elif grid[x][y] == ' ': op_in('I',1)
            else:
                if inp_inst == 0:
                    inp_inst += 1
                    op_in('I',code1)    # bei der ersten Ansteuerung des Amplifiers wird der Initialwert aus dem 5-stelligen Code genommen
                elif inp_inst == 1:
                    op_in('I',code2)    # ab dem 2.Lauf wird immer der aktuelle Out-Wert (=Out-Wert des letzten Amplifier) genommen
                else:
                    op_in('0',0)
            continue
        if liste[i] == 4:
            if mode == 'LOOP':
                erg = op_out('0')
                i += 2
                return (erg)
            elif mode == 'TEST':
                op_out('0')
            elif mode == 'ROBOT':
                op_out('0')
            continue
        if liste[i] == 5:
            op_true('0', '0')
            continue
        if liste[i] == 6:
            op_false('0', '0')
            continue
        if liste[i] == 7:
            op_less('0','0','0')
            continue
        if liste[i] == 8:
            op_equal('0','0','0')
            continue
        if liste[i] == 9:
            op_relative('0')
            continue
        if liste[i] > 4:
            instruct = str(liste[i])
            while len(instruct) < 5: instruct = '0' + instruct
            opcode = instruct[3:]

            if opcode == '01':
                memory_check(instruct[0],[liste[i+3]+relative_base])
                value1, value2 = val_instruct(instruct[1], instruct[2])     #v1 erste Zahl nach 01, v2 zweite Zahlen nach 01
                if instruct[0] == '0': op_add(liste[i + 3], value1, value2)
                elif instruct[0] == '1': op_add(i+3, value1, value2)
                elif instruct[0] == '2': op_add(liste[i + 3] + relative_base, value1, value2)
            elif opcode == '02':
                memory_check(instruct[0], [liste[i + 3]+relative_base])
                value1, value2 = val_instruct(instruct[1], instruct[2])     #v1 erste Zahl nach 01, v2 zweite Zahlen nach 01
                if instruct[0] == '0': op_mult(liste[i + 3], value1, value2)
                elif instruct[0] == '1': op_mult(i+3, value1, value2)
                elif instruct[0] == '2': op_mult(liste[i + 3] + relative_base, value1, value2)
            elif opcode == '03':
                if mode == "ROBOT":
                    if grid[x][y] == 'B':
                        op_in('I', 0)
                    elif grid[x][y] == ' ': op_in('I', 1)
                else:
                    op_in(instruct[2],0)
            elif opcode == '04':
                if mode == 'LOOP':
                    erg=op_out(instruct[2])
                    return (erg)
                elif mode == 'TEST':
                    op_out(instruct[2])
                elif mode == 'ROBOT':
                    op_out(instruct[2])
            elif opcode == '05':
                op_true(instruct[1],instruct[2])
            elif opcode == '06':
                op_false(instruct[1],instruct[2])
            elif opcode == '07':
                op_less(instruct[0],instruct[1],instruct[2])
            elif opcode == '08':
                memory_check(instruct[2]+instruct[1]+instruct[0], [liste[i + 1], liste[i+2], liste[i+3]])
                op_equal(instruct[0],instruct[1],instruct[2])
            elif opcode == '09':
                memory_check(instruct[2], [liste[i + 1]+relative_base])
                op_relative(instruct[2])
            else: print ("Error OPCODE ", opcode)

# Einschränkung auf einen Testfall
# test = [('9', '8', '7', '6', '5')]
# combi = list(test)
# print (combi)

#Advent11 Part1
ergebnis = 0
fields = []
mode = 'ROBOT'
relative_base = 0
liste = liste_src
robo_color = ' '
robo_dir = 'O'
i = 0
x = 50; y = 50

gridline = []
for j in range(1000):
    gridline.append("B")
grid = []
for j in range(1000):
    grid.append(list(gridline))


int_comp(0, 0)
print ('Ergebnis: ', ergebnis)
print(fields)
print(relative_base)

#Advent09 Part1 + Part2
# ergebnis = 0
# mode = 'TEST'
# relative_base = 0
# liste = liste_src
# liste.append(0)
# i = 0
# int_comp(1,0)

#Advent 07
# combi = make_combi('56789')
# ergebnis = 0
# mode = 'LOOP'
# for a in combi:
#     out = 0
#     ind_AbisE = []
#     li_AbisE = []
#     loop = True
#     for b in a:     # Initialer Start der Amplifier mit Startwert
#         i=0
#         inp_inst = 0        # Abfrge wg. Initialisierung der Amplifier
#         liste = liste_src
#         out=int_comp(int(b),out)
#         ind_AbisE.append(i)     # Liste mit Indizes der einzelnen Amplifiers
#         li_AbisE.append(list(liste))  # Liste mit den aktuellen Werten der einzelnen Amplifiers
# #        print ('Amp:', len(ind_AbisE), 'Index:', i, 'Out:', out, 'Liste:', liste)
#
#     amp=0
#     while loop:     # Laufender Betrieb der Amplifier mit Output von vorherigem Amplifier bis Ende mit 99 erreicht bei Amplifier E
#         i=ind_AbisE[amp]
#         liste=list(li_AbisE[amp])
#         out=int_comp(int(a[amp]),out)
#         ind_AbisE[amp]=i
#         li_AbisE[amp]=list(liste)
# #        print('Amp:', amp+1, 'Index:', i, 'Out:', out, 'Liste:', liste)
#
#         if loop == False and amp == 4:
#             break
#         else:
#             loop = True
#         ind_AbisE[amp] = i
#         li_AbisE[amp] = list(liste)
#         if amp == 4:
#             amp = 0
#         else:
#             amp += 1
#
#     if out > ergebnis:
#         ergebnis = out
#         ergebnis_combi = a
#
# print (ergebnis)
# print (ergebnis_combi)

















